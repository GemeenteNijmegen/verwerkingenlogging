# verwerkingenlogging

## Versie 1 
Source: https://github.com/GemeenteNijmegen/verwerkingenlogging/tree/fef86db1a339d4ab33e07669bd401323ba47fefa
In deze versie bestaat er geen sort key. Dit betekent dat de primary key enkel bestaat uit de partition key (actieId).
Dit maakt de implementatie efficienter wanneer er gebruik wordt gemaakt van DynamoDB. Zo is het bijvoorbeeld mogelijk om direct een verzoek te doen vanuit de api gateway naar dynamodb. Zo fungeert de api gateway als een (directe) proxy. Voorbeeld: een GET /verwerkingsacties/{actieId} geeft een directe response vanuit de database zonder dat hier logica (binnen een lamdba) nodig is. Dit is gunstig voor de performance. Alle verkingsacties/{actieId}, dus dat zijn GET, PUT en DELETE, zijn direct te benaderen. De overige /verwerkingsacties routes hebben meer logica nodig. Zo heeft de GET /verwerkingsacties een reeks aan optionele paramters waardoor er verschillende mogelijkheden zijn om een verzoek te doen richting de databese. Hiervoor is een lamdba nodig om het verzoek te verwerken. Voor de POST and PATCH is er gekozen voor een event-driven opzet. Het is namelijk mogelijk dat een groot aantal verzoeken worden gedaan vanuit de applicatie(s). De response heeft een actieId, verwerktObjectId en URL nodig, de rest is direct besckikbaar in het verzoek vanuit de applicatie(s). Om direct een response te kunnen geven aan de applicatie(s) wordt het verzoek op de queue gezet om later aan de database toegevoegd te worden. Hierdoor is het niet nodig voor de applicatie(s) om te wachten op de verwerking (opslaan in DB).

## Versie 2
Source: ?
In deze versie bestaat er zowel een sort key als een partition key. Deze vormen samen de primary key in de DynamoDb database. De partition key is 'actieId' en de sort key is 'soortObjectTypeId' wat een combinatie is van de waarde's 'objecttype', 'soortObjectId' en 'objectId'. Dit zorgt voor een one-to-many relatie waarbij er meerdere soortObjecTypeId's onder één actieId kunnen vallen. In de databese bestaat er een kopie van de verwerkingsactie voor elk verwerkte object. Voorbeeld: als een verwerkingsactie met vier verwerkte objecten wordt geregistreerd dan worden er vier nieuwe records aan de database toegevoegd met ieder een uniek soortObjecTypeId. De rest van de record is identiek. Dit geeft de mogelijkheid om op een later moment alle verwerkingsacties van een specifiek verwerkt object (persoon) op te halen. In versie 1 is dit niet mogelijk. Het nadeel van versie 2 (deze versie) is dat het meer logica vereist met name aan de /verwerkingsacties/{actieId} kant. Dit bekent ook een verlies in performance. Buiten een verlies in peformance zorgt het gebruik van een sort key er ook voor dat er aanzienlijk meer records in de database zullen staan.
    
